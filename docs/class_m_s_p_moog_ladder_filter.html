<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TR123e - EMCT Computing Final Project: MSPMoogLadderFilter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TR123e - EMCT Computing Final Project<span id="projectnumber">&#160;Version 1.0</span>
   </div>
   <div id="projectbrief">Research Project Translation from gen~ to embedded Moog synth</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_m_s_p_moog_ladder_filter.html','','class_m_s_p_moog_ladder_filter-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">MSPMoogLadderFilter Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>High-fidelity Moog ladder filter implementing Huovilainen's nonlinear model.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_m_s_p_moog_ladder_filter_8h_source.html">MSPMoogLadderFilter.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac9dc2c7f55ac2cf8839ba9f386abd1c4" id="r_ac9dc2c7f55ac2cf8839ba9f386abd1c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9dc2c7f55ac2cf8839ba9f386abd1c4">MSPMoogLadderFilter</a> (double <a class="el" href="#a24fa7d208982a7f7a32e56aa61163768">sampleRate</a>)</td></tr>
<tr class="memdesc:ac9dc2c7f55ac2cf8839ba9f386abd1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct MSP Moog ladder filter with sample rate configuration.  <br /></td></tr>
<tr class="memitem:ab331fca52ca6edab349fa55d9145b3e5" id="r_ab331fca52ca6edab349fa55d9145b3e5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab331fca52ca6edab349fa55d9145b3e5">processSample</a> (double inputSignal, double envelopeControl, double resonanceControl, double thermalNoise, int filterMode)</td></tr>
<tr class="memdesc:ab331fca52ca6edab349fa55d9145b3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process single audio sample through complete Huovilainen ladder algorithm.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pri-methods" class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac23a77e19abe261fe0288f99d95338de" id="r_ac23a77e19abe261fe0288f99d95338de"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac23a77e19abe261fe0288f99d95338de">fixDenormalNumbers</a> (double value)</td></tr>
<tr class="memdesc:ac23a77e19abe261fe0288f99d95338de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denormal number protection for CPU performance optimization.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pri-attribs" class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a71783071551725acfa140ecd62e32c24" id="r_a71783071551725acfa140ecd62e32c24"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71783071551725acfa140ecd62e32c24">previousInput</a></td></tr>
<tr class="memdesc:a71783071551725acfa140ecd62e32c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Previous input sample for delay line implementation.  <br /></td></tr>
<tr class="memitem:ac92231643e8c95c2e4d23b0bc860b3f2" id="r_ac92231643e8c95c2e4d23b0bc860b3f2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac92231643e8c95c2e4d23b0bc860b3f2">resonanceCoefficient</a></td></tr>
<tr class="memdesc:ac92231643e8c95c2e4d23b0bc860b3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current resonance coefficient for feedback calculations.  <br /></td></tr>
<tr class="memitem:adad646067cba3736c7c82c47892d237b" id="r_adad646067cba3736c7c82c47892d237b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adad646067cba3736c7c82c47892d237b">cutoffFrequency</a></td></tr>
<tr class="memdesc:adad646067cba3736c7c82c47892d237b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current normalized cutoff frequency.  <br /></td></tr>
<tr class="memitem:ac5ae12a14690568e4f8abd41233431d2" id="r_ac5ae12a14690568e4f8abd41233431d2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5ae12a14690568e4f8abd41233431d2">stage1State</a></td></tr>
<tr class="memdesc:ac5ae12a14690568e4f8abd41233431d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">First filter stage state variable.  <br /></td></tr>
<tr class="memitem:a268265c068ac0c3b46f2b8e65c74cd00" id="r_a268265c068ac0c3b46f2b8e65c74cd00"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a268265c068ac0c3b46f2b8e65c74cd00">stage2State</a></td></tr>
<tr class="memdesc:a268265c068ac0c3b46f2b8e65c74cd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second filter stage state variable.  <br /></td></tr>
<tr class="memitem:a9598bd5b17b7e65d3da12e8f30575569" id="r_a9598bd5b17b7e65d3da12e8f30575569"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9598bd5b17b7e65d3da12e8f30575569">stage3State</a></td></tr>
<tr class="memdesc:a9598bd5b17b7e65d3da12e8f30575569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Third filter stage state variable.  <br /></td></tr>
<tr class="memitem:ad54c25fb0f5237829c8032ab057765d3" id="r_ad54c25fb0f5237829c8032ab057765d3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad54c25fb0f5237829c8032ab057765d3">stage4State</a></td></tr>
<tr class="memdesc:ad54c25fb0f5237829c8032ab057765d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fourth filter stage state variable.  <br /></td></tr>
<tr class="memitem:ad5f2704ec5dc162d262025d528486f18" id="r_ad5f2704ec5dc162d262025d528486f18"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5f2704ec5dc162d262025d528486f18">saturationState</a></td></tr>
<tr class="memdesc:ad5f2704ec5dc162d262025d528486f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonlinear saturation state for feedback processing.  <br /></td></tr>
<tr class="memitem:a0f617a374ba5281bb94a2cd97d3f560e" id="r_a0f617a374ba5281bb94a2cd97d3f560e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f617a374ba5281bb94a2cd97d3f560e">stage4DelayedOutput</a></td></tr>
<tr class="memdesc:a0f617a374ba5281bb94a2cd97d3f560e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delayed output from fourth stage for mode calculations.  <br /></td></tr>
<tr class="memitem:a30ce9185b837b37d347fa2fbe6e21646" id="r_a30ce9185b837b37d347fa2fbe6e21646"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30ce9185b837b37d347fa2fbe6e21646">combinedOutput1</a></td></tr>
<tr class="memdesc:a30ce9185b837b37d347fa2fbe6e21646"><td class="mdescLeft">&#160;</td><td class="mdescRight">First combined output signal for multi-mode processing.  <br /></td></tr>
<tr class="memitem:a5e7d6fba6f88b9b25f8c48c8bb174153" id="r_a5e7d6fba6f88b9b25f8c48c8bb174153"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e7d6fba6f88b9b25f8c48c8bb174153">combinedOutput2</a></td></tr>
<tr class="memdesc:a5e7d6fba6f88b9b25f8c48c8bb174153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second combined output signal for mode processing.  <br /></td></tr>
<tr class="memitem:a47bc3baa76db4637be1796930d38c75a" id="r_a47bc3baa76db4637be1796930d38c75a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47bc3baa76db4637be1796930d38c75a">finalFilterOutput</a></td></tr>
<tr class="memdesc:a47bc3baa76db4637be1796930d38c75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final filter output delay element.  <br /></td></tr>
<tr class="memitem:a24fa7d208982a7f7a32e56aa61163768" id="r_a24fa7d208982a7f7a32e56aa61163768"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24fa7d208982a7f7a32e56aa61163768">sampleRate</a></td></tr>
<tr class="memdesc:a24fa7d208982a7f7a32e56aa61163768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio system sample rate in Hz.  <br /></td></tr>
<tr class="memitem:a792a10162938c5c4c6640a50d449c64c" id="r_a792a10162938c5c4c6640a50d449c64c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a792a10162938c5c4c6640a50d449c64c">frequencyScaleFactor</a></td></tr>
<tr class="memdesc:a792a10162938c5c4c6640a50d449c64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frequency scaling factor optimized for current sample rate.  <br /></td></tr>
<tr class="memitem:adb5a84d9e4fbf97f75a829d38a8d9042" id="r_adb5a84d9e4fbf97f75a829d38a8d9042"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb5a84d9e4fbf97f75a829d38a8d9042">frequencyWarpFactor</a></td></tr>
<tr class="memdesc:adb5a84d9e4fbf97f75a829d38a8d9042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frequency warping compensation factor for bilinear transform.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>High-fidelity Moog ladder filter implementing Huovilainen's nonlinear model. </p>
<p><br  />
 </p>
<p>This class provides a complete implementation of Antti Huovilainen's improved Moog ladder filter model, translated directly from Max/MSP Gen~ code. It features advanced nonlinear modeling, thermal noise simulation, and multiple filter modes while maintaining the computational efficiency required for real-time audio processing.</p>
<p>@design_philosophy</p><ul>
<li><b>Accuracy</b>: Faithful reproduction of analog nonlinear behavior</li>
<li><b>Efficiency</b>: Optimized for real-time audio processing constraints <br  />
</li>
<li><b>Completeness</b>: Six filter modes from single unified topology</li>
<li><b>Stability</b>: Robust numerical behavior across parameter ranges</li>
<li><b>Authenticity</b>: Preserves analog warmth through nonlinear modeling</li>
</ul>
<p>@implementation_highlights</p><ul>
<li><b>Dual-Pass Algorithm</b>: Two iterations per sample for enhanced accuracy</li>
<li><b>Multiple Saturation Stages</b>: Different nonlinear characteristics per stage</li>
<li><b>Frequency Warping Compensation</b>: Accurate frequency response preservation</li>
<li><b>Denormal Protection</b>: Prevents CPU performance degradation</li>
<li><b>Parameter Smoothing</b>: Built-in interpolation for artifact-free control</li>
</ul>
<p>@musical_applications</p><ul>
<li>Vintage synthesizer emulation and restoration projects</li>
<li>Modern digital synthesizers requiring authentic analog character</li>
<li>Audio effects processing with multiple filter response options</li>
<li>Sound design applications requiring precise frequency control</li>
<li>Research platforms for nonlinear digital filter analysis</li>
</ul>
<p>@usage_example </p><div class="fragment"><div class="line"><a class="code hl_function" href="#ac9dc2c7f55ac2cf8839ba9f386abd1c4">MSPMoogLadderFilter</a> filter(44100.0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In audio processing loop:</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_variable" href="render__with___m_o_o_g_f_i_l_t_e_r_8cpp.html#a8556d19b129aa550f5b2819ed0320e83">bufferSize</a>; ++i) {</div>
<div class="line">    <span class="keywordtype">double</span> <a class="code hl_variable" href="render__with___m_o_o_g_f_i_l_t_e_r_8cpp.html#a3586695b54c8d8d1c78b4c9d56f462d5">envelope</a> = envelopeValue;        <span class="comment">// 0.0 - 1.0</span></div>
<div class="line">    <span class="keywordtype">double</span> resonance = resonanceControl;    <span class="comment">// 0.0 - 1.0+</span></div>
<div class="line">    <span class="keywordtype">double</span> noise = thermalNoiseGenerator(); <span class="comment">// Very small random value</span></div>
<div class="line">    <span class="keywordtype">int</span> mode = 0;                          <span class="comment">// 0=LP24, 1=HP24, etc.</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">double</span> filtered = filter.processSample(</div>
<div class="line">        <a class="code hl_variable" href="render__with___m_o_o_g_f_i_l_t_e_r_8cpp.html#a17f47df573d6d0557902f8d50036eea4">inputBuffer</a>[i], <a class="code hl_variable" href="render__with___m_o_o_g_f_i_l_t_e_r_8cpp.html#a3586695b54c8d8d1c78b4c9d56f462d5">envelope</a>, resonance, noise, mode</div>
<div class="line">    );</div>
<div class="line">    <a class="code hl_variable" href="render__with___m_o_o_g_f_i_l_t_e_r_8cpp.html#ad6b1fd58fc6b838cd5927d4925b30812">outputBuffer</a>[i] = filtered;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_m_s_p_moog_ladder_filter_html_ac9dc2c7f55ac2cf8839ba9f386abd1c4"><div class="ttname"><a href="#ac9dc2c7f55ac2cf8839ba9f386abd1c4">MSPMoogLadderFilter::MSPMoogLadderFilter</a></div><div class="ttdeci">MSPMoogLadderFilter(double sampleRate)</div><div class="ttdoc">Construct MSP Moog ladder filter with sample rate configuration.</div><div class="ttdef"><b>Definition</b> MSPMoogLadderFilter.cpp:37</div></div>
<div class="ttc" id="arender__with___m_o_o_g_f_i_l_t_e_r_8cpp_html_a17f47df573d6d0557902f8d50036eea4"><div class="ttname"><a href="render__with___m_o_o_g_f_i_l_t_e_r_8cpp.html#a17f47df573d6d0557902f8d50036eea4">inputBuffer</a></div><div class="ttdeci">float * inputBuffer</div><div class="ttdef"><b>Definition</b> render_with_MOOGFILTER.cpp:114</div></div>
<div class="ttc" id="arender__with___m_o_o_g_f_i_l_t_e_r_8cpp_html_a3586695b54c8d8d1c78b4c9d56f462d5"><div class="ttname"><a href="render__with___m_o_o_g_f_i_l_t_e_r_8cpp.html#a3586695b54c8d8d1c78b4c9d56f462d5">envelope</a></div><div class="ttdeci">ADSR envelope</div><div class="ttdef"><b>Definition</b> render_with_MOOGFILTER.cpp:91</div></div>
<div class="ttc" id="arender__with___m_o_o_g_f_i_l_t_e_r_8cpp_html_a8556d19b129aa550f5b2819ed0320e83"><div class="ttname"><a href="render__with___m_o_o_g_f_i_l_t_e_r_8cpp.html#a8556d19b129aa550f5b2819ed0320e83">bufferSize</a></div><div class="ttdeci">int bufferSize</div><div class="ttdef"><b>Definition</b> render_with_MOOGFILTER.cpp:116</div></div>
<div class="ttc" id="arender__with___m_o_o_g_f_i_l_t_e_r_8cpp_html_ad6b1fd58fc6b838cd5927d4925b30812"><div class="ttname"><a href="render__with___m_o_o_g_f_i_l_t_e_r_8cpp.html#ad6b1fd58fc6b838cd5927d4925b30812">outputBuffer</a></div><div class="ttdeci">float * outputBuffer</div><div class="ttdef"><b>Definition</b> render_with_MOOGFILTER.cpp:115</div></div>
</div><!-- fragment --> </div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac9dc2c7f55ac2cf8839ba9f386abd1c4" name="ac9dc2c7f55ac2cf8839ba9f386abd1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9dc2c7f55ac2cf8839ba9f386abd1c4">&#9670;&#160;</a></span>MSPMoogLadderFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MSPMoogLadderFilter::MSPMoogLadderFilter </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>sampleRate</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct MSP Moog ladder filter with sample rate configuration. </p>
<p>Initialize MSP Moog ladder filter with comprehensive state setup.</p>
<p>Initializes the filter with sample-rate dependent parameters and clears all internal state variables. The constructor performs extensive precomputation of sample-rate dependent constants to optimize real-time processing performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampleRate</td><td>Audio processing sample rate in Hz Used for frequency warping calculations and stability analysis Range: [8000-192000] Hz typical for professional audio Higher rates improve frequency accuracy but increase CPU load</td></tr>
  </table>
  </dd>
</dl>
<p>@complexity O(1) - Constant time initialization with mathematical precomputation @memory 120 bytes object size (15 × 8-byte doubles) @thread_safety Safe for concurrent construction</p>
<p>@initialization_process</p><ol type="1">
<li><b>State Variable Clearing</b>: All filter memory set to zero for clean startup</li>
<li><b>Frequency Scale Calculation</b>: Sample-rate dependent scaling factors</li>
<li><b>Warping Factor Computation</b>: Bilinear transform compensation parameters</li>
<li><b>Safety Limit Establishment</b>: Bounds checking for numerical stability</li>
</ol>
<p>@precomputed_constants</p><ul>
<li><b>frequencyScaleFactor</b>: Optimizes frequency range for given sample rate</li>
<li><b>frequencyWarpFactor</b>: Compensates for bilinear transform artifacts</li>
<li><b>maxFreqRatio</b>: Prevents instability at extreme sample rates</li>
</ul>
<p>@numerical_stability The constructor implements several stability measures:</p><ul>
<li>Frequency ratio clamping to [0.0001, 1.0] range</li>
<li>Logarithmic frequency warping with bounds checking</li>
<li>Initial state zeroing to prevent startup artifacts</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampleRate</td><td>Audio processing sample rate for system configuration</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor performs extensive initialization including state variable clearing, sample-rate dependent constant precomputation, and stability parameter calculation. The initialization process ensures optimal performance during real-time audio processing by front-loading all computationally expensive operations. </p>
<p>Clear all filter state variables to ensure clean startup behavior. This prevents artifacts from uninitialized memory and provides deterministic filter response from the first processed sample.</p>
<p>Calculate frequency scaling factor with protective bounds checking. This factor optimizes the filter's frequency range and stability characteristics for the current sample rate while preventing numerical instability at extreme sample rates.</p>
<p>The formula balances frequency range, stability, and accuracy:</p><ul>
<li>12.5/sampleRate provides the base frequency scaling relationship</li>
<li>min(1.0, ...) prevents excessive scaling at low sample rates <br  />
</li>
<li>max(0.0001, ...) prevents numerical underflow at high sample rates</li>
<li>sqrt(...) applies nonlinear compression for improved behavior</li>
</ul>
<p>Calculate frequency warping compensation factor using logarithmic mapping. This factor compensates for the frequency compression effects inherent in bilinear transform implementations, ensuring that the digital filter's frequency response accurately matches the analog prototype.</p>
<p>The negative logarithm creates an inverse mapping that:</p><ul>
<li>Expands compressed frequency ranges in the digital domain</li>
<li>Provides sample-rate independent frequency response</li>
<li>Maintains analog-accurate cutoff frequency relationships</li>
</ul>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ac23a77e19abe261fe0288f99d95338de" name="ac23a77e19abe261fe0288f99d95338de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23a77e19abe261fe0288f99d95338de">&#9670;&#160;</a></span>fixDenormalNumbers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MSPMoogLadderFilter::fixDenormalNumbers </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Denormal number protection for CPU performance optimization. </p>
<p>Denormal number protection for sustained CPU performance.</p>
<p>Prevents denormal floating-point numbers that can cause severe CPU performance degradation in recursive digital filters. Denormal numbers occur when floating-point values become extremely small (near the representational limits) and require special handling by the processor's floating-point unit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Input floating-point value to be checked and potentially corrected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0.0 if input is denormal, otherwise returns original value unchanged</dd></dl>
<p>@complexity O(1) - Single comparison and conditional assignment @threshold 1×10⁻¹⁸ (well below normal audio signal levels) @performance_impact Critical for maintaining real-time performance in recursive filters</p>
<p>@denormal_theory Denormal numbers occur when:</p><ul>
<li>Magnitude &lt; minimum normalized floating-point value (~1×10⁻³⁰⁸ for double)</li>
<li>Mantissa has leading zeros, requiring special CPU handling</li>
<li>Processing speed can decrease by 100x or more</li>
<li>Particularly problematic in feedback loops where small values accumulate</li>
</ul>
<p>@musical_relevance In audio contexts, denormal numbers typically arise from:</p><ul>
<li>Filter decay tails approaching silence</li>
<li>Numerical errors in recursive calculations</li>
<li>Very quiet audio signals with accumulated rounding errors</li>
<li>Feedback loops with high Q that generate very small oscillations</li>
</ul>
<p>@implementation_note The threshold of 1×10⁻¹⁸ is chosen to be well below any musically relevant audio levels while being high enough to catch denormal numbers before they impact CPU performance. This threshold represents approximately -360dB, far below the noise floor of any practical audio system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Input value to check for denormal condition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0.0 if denormal, otherwise original value</dd></dl>
<p>This function provides essential protection against denormal floating-point numbers that can cause severe CPU performance degradation in recursive digital filters. The function uses a threshold well below any musically relevant signal levels to identify and eliminate denormal conditions.</p>
<p>@performance_impact Without denormal protection, recursive filters can experience:</p><ul>
<li>100x or greater CPU performance degradation</li>
<li>Inconsistent real-time performance</li>
<li>Audio dropouts in resource-constrained systems</li>
<li>Thermal throttling in mobile devices</li>
</ul>
<p>@threshold_selection The 1×10⁻¹⁸ threshold is chosen because:</p><ul>
<li>Well below -360dB (inaudible in any practical system)</li>
<li>High enough to catch IEEE 754 denormal range</li>
<li>Preserves all musically relevant signal content</li>
<li>Provides consistent performance across platforms </li>
</ul>
<p>Check if absolute value falls below denormal threshold. Values this small indicate denormal floating-point representation that requires special CPU handling and causes performance degradation.</p>

</div>
</div>
<a id="ab331fca52ca6edab349fa55d9145b3e5" name="ab331fca52ca6edab349fa55d9145b3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab331fca52ca6edab349fa55d9145b3e5">&#9670;&#160;</a></span>processSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MSPMoogLadderFilter::processSample </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>inputSignal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>envelopeControl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>resonanceControl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>thermalNoise</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>filterMode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process single audio sample through complete Huovilainen ladder algorithm. </p>
<p>Process single audio sample through complete Huovilainen algorithm.</p>
<p>Implements the complete Huovilainen model including dual-iteration processing, nonlinear saturation modeling, thermal noise injection, and mode-dependent output selection. This method encapsulates the entire filter algorithm in a single function call optimized for real-time audio processing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputSignal</td><td>Input audio sample for filtering Range: [-1.0, +1.0] typical for normalized audio No automatic limiting (relies on input conditioning)</td></tr>
    <tr><td class="paramname">envelopeControl</td><td>Cutoff frequency control signal [0.0-1.0] Nonlinear mapping to frequency range 0.0 = lowest frequency, 1.0 = highest frequency Exponential response curve for musical control</td></tr>
    <tr><td class="paramname">resonanceControl</td><td>Resonance intensity control [0.0-1.0+] 0.0 = no resonance (flat response) 1.0 = high resonance (approaching self-oscillation) &gt;1.0 = potential self-oscillation (use with caution)</td></tr>
    <tr><td class="paramname">thermalNoise</td><td>Small random signal for analog realism Typical amplitude: ~1×10⁻¹¹ (very small) Simulates Johnson noise in analog circuits Can be zero for purely digital character</td></tr>
    <tr><td class="paramname">filterMode</td><td>Filter response type selection [0-5] 0: LP24 (24dB/octave lowpass) 1: HP24 (24dB/octave highpass) <br  />
 2: BP24 (24dB/octave bandpass) 3: LP18 (18dB/octave lowpass) 4: BP18 (18dB/octave bandpass) 5: HP6 (6dB/octave highpass) Invalid modes default to LP24</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Filtered audio sample Range depends on resonance and mode settings May exceed input range at high resonance (self-oscillation) Contains nonlinear harmonic content when drive is applied</dd></dl>
<p>@complexity O(1) - Fixed computational cost regardless of parameters @precision IEEE 754 double precision (64-bit) floating-point @realtime_safety Real-time safe (deterministic execution time, no allocation)</p>
<p>@algorithm_phases <b>Phase 1</b>: Cutoff frequency calculation with envelope mapping <b>Phase 2</b>: Resonance coefficient calculation with frequency compensation <b>Phase 3</b>: First iteration - initial filter processing with nonlinearity <b>Phase 4</b>: Second iteration - refined processing for improved accuracy <b>Phase 5</b>: Mode selection and output calculation <b>Phase 6</b>: State variable updates for next sample</p>
<p>@nonlinear_modeling_details The method implements multiple types of nonlinearity:</p><ul>
<li><b>Feedback Saturation</b>: Soft limiting in resonance feedback path</li>
<li><b>Stage Saturation</b>: Cubic limiting in filter stages <br  />
</li>
<li><b>Thermal Noise</b>: Random perturbation for analog character</li>
<li><b>Frequency-Dependent Behavior</b>: Nonlinearity varies with cutoff frequency</li>
</ul>
<p>@dual_iteration_rationale The two-pass algorithm provides:</p><ul>
<li><b>Improved Accuracy</b>: Iterative refinement of nonlinear calculations</li>
<li><b>Better Stability</b>: Reduced numerical errors in feedback loops</li>
<li><b>Enhanced Realism</b>: More accurate modeling of analog behavior</li>
<li><b>Consistent Response</b>: Predictable behavior across parameter ranges</li>
</ul>
<p>@performance_analysis Approximate operation count per sample:</p><ul>
<li>Frequency calculation: ~20 operations (polynomial evaluation)</li>
<li>Resonance calculation: ~15 operations (feedback compensation)</li>
<li>First iteration: ~25 operations (4 stages + nonlinearity)</li>
<li>Second iteration: ~25 operations (refined processing)</li>
<li>Mode selection: ~5 operations (output calculation)</li>
<li>State updates: ~10 operations (memory updates)</li>
<li><b>Total</b>: ~100 floating-point operations per sample</li>
</ul>
<p>@call_pattern Must be called exactly once per audio sample for proper timing: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> sample = 0; sample &lt; <a class="code hl_variable" href="render__with___m_o_o_g_f_i_l_t_e_r_8cpp.html#a8556d19b129aa550f5b2819ed0320e83">bufferSize</a>; ++sample) {</div>
<div class="line">    <span class="keywordtype">double</span> filtered = filter.processSample(</div>
<div class="line">        <a class="code hl_variable" href="render__with___m_o_o_g_f_i_l_t_e_r_8cpp.html#a17f47df573d6d0557902f8d50036eea4">inputBuffer</a>[sample], <a class="code hl_variable" href="render__with___m_o_o_g_f_i_l_t_e_r_8cpp.html#a3586695b54c8d8d1c78b4c9d56f462d5">envelope</a>[sample], </div>
<div class="line">        resonance[sample], noise[sample], mode</div>
<div class="line">    );</div>
<div class="line">    <a class="code hl_variable" href="render__with___m_o_o_g_f_i_l_t_e_r_8cpp.html#ad6b1fd58fc6b838cd5927d4925b30812">outputBuffer</a>[sample] = filtered;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This method implements the complete dual-iteration Huovilainen algorithm with comprehensive nonlinear modeling, thermal noise injection, and multi-mode output selection. The implementation follows the exact structure of the original Gen~ code while providing enhanced documentation and optimization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputSignal</td><td>Input audio sample for filtering </td></tr>
    <tr><td class="paramname">envelopeControl</td><td>Frequency control envelope [0.0-1.0] </td></tr>
    <tr><td class="paramname">resonanceControl</td><td>Resonance intensity [0.0-1.0+] </td></tr>
    <tr><td class="paramname">thermalNoise</td><td>Random noise for analog simulation </td></tr>
    <tr><td class="paramname">filterMode</td><td>Filter response selection [0-5] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Filtered audio sample with nonlinear characteristics </dd></dl>
<p>Transform envelope control signal to cutoff frequency using nonlinear mapping. This section implements the frequency control characteristic that provides musical frequency scaling from the linear envelope control input.</p>
<p>The mapping process includes:</p><ol type="1">
<li>Linear scaling and offset for frequency range definition</li>
<li>Normalization to standard control range</li>
<li>Safety clamping to prevent filter instability</li>
<li>Frequency warping compensation application</li>
<li>Polynomial approximation for efficient exponential mapping</li>
<li>Power series expansion through efficient repeated squaring</li>
</ol>
<p>Apply linear scaling and offset to envelope control signal. These coefficients define the frequency control range and response curve:</p><ul>
<li>0.90193: Scaling factor that determines the frequency span</li>
<li>7.29: Offset that sets the minimum frequency point</li>
<li>127.0: Normalization factor for standard MIDI-style control range</li>
</ul>
<p>Apply safety clamping to prevent filter instability and undefined behavior. The upper limit of 0.99 ensures the filter remains stable and prevents numerical overflow in subsequent exponential calculations.</p>
<p>Apply frequency warping compensation to correct for bilinear transform effects. This multiplication by the precomputed warping factor ensures that the digital filter's cutoff frequency accurately corresponds to the analog prototype frequency across all sample rates.</p>
<p>Calculate frequency response using polynomial approximation for efficiency. This polynomial provides a computationally efficient approximation to the exponential frequency mapping while maintaining adequate accuracy for musical applications. The coefficients are optimized for the frequency range of interest in audio processing.</p>
<p>Apply exponential scaling through efficient repeated squaring method. This approach provides the equivalent of raising the polynomial result to the 32nd power (frequencyPolynomial^32) using only 5 multiplication operations instead of 31, significantly optimizing computational efficiency while maintaining numerical precision.</p>
<p>Apply final frequency scaling using the precomputed sample-rate factor. This combines the exponential frequency mapping with sample-rate dependent scaling to produce the final normalized cutoff frequency.</p>
<p>Implement frequency change smoothing to prevent audio artifacts. This simple first-order lowpass smoothing reduces zipper noise and other artifacts that can occur during rapid frequency changes, particularly important for real-time frequency modulation.</p>
<p>Calculate resonance feedback coefficients with comprehensive nonlinearity and frequency-dependent compensation. This section implements the complex resonance behavior that accounts for the frequency-dependent Q characteristics observed in the analog Moog ladder filter.</p>
<p>Calculate frequency-dependent resonance compensation factor. This models the way resonance behavior changes with cutoff frequency in the analog circuit, where higher frequencies exhibit different resonance characteristics due to parasitic effects and nonlinear behavior.</p>
<p>Calculate nonlinear resonance scaling using polynomial approximation. This polynomial models the frequency-dependent resonance behavior observed in analog circuits, where resonance effectiveness varies nonlinearly with both frequency and resonance control settings.</p>
<p>Calculate feedback strength with comprehensive frequency compensation. This calculation determines the amount of positive feedback around the filter ladder, accounting for both the desired resonance level and the frequency-dependent corrections needed for accurate modeling.</p>
<p>Calculate input scaling factor for gain and feedback interaction control. This parameter affects both the overall filter gain and the way the input signal interacts with the resonance feedback, modeling the complex gain relationships in the analog circuit.</p>
<p>Calculate inverse resonance scaling for forward signal path. This complementary scaling factor ensures proper signal balance between the resonance feedback path and the forward signal path, maintaining overall filter stability and desired frequency response.</p>
<p>Update resonance coefficient with temporal smoothing. This smoothing prevents artifacts during resonance parameter changes while the 1.05 scaling factor allows for slight over-resonance to achieve self-oscillation when desired.</p>
<p>Process input signal through the complete ladder filter topology with nonlinear elements and feedback. This first iteration establishes the initial filter state and provides the foundation for the second iteration that refines the accuracy of the nonlinear modeling.</p>
<p>Add thermal noise to input signal for enhanced analog realism. The extremely small amplitude (1×10⁻¹¹) simulates Johnson noise present in analog circuits without significantly affecting the audio signal but contributing to the organic character of the filter.</p>
<p>Retrieve and protect previous input value from denormal numbers. This ensures numerical stability while maintaining the delay element necessary for the recursive filter structure.</p>
<p>Calculate feedback signal combining input scaling and resonance feedback. This implements the negative feedback topology that creates the resonance effect by subtracting a scaled version of the filter output from the scaled input signal.</p>
<p>Apply nonlinear saturation to feedback signal modeling transistor behavior. This saturation process simulates the soft-clipping characteristics of bipolar junction transistors in the analog ladder filter, contributing to the warm, musical character of the filter response.</p>
<p>Apply saturation curve modeling soft clipping behavior. This nonlinear function approximates the transfer characteristic of saturated transistors, providing gentle limiting that adds harmonic content without harsh distortion artifacts.</p>
<p>STAGE 1: First lowpass pole with resonance scaling. This stage begins the cascade of four identical lowpass sections, each contributing 6dB/octave to the overall 24dB/octave response. The resonance scaling affects how the feedback interacts with each stage.</p>
<p>Calculate scaled outputs for efficient coefficient application. The 0.3 coefficient determines the cutoff frequency of each pole and is applied to multiple signals for computational efficiency.</p>
<p>STAGE 2: Second lowpass pole in cascade configuration. This stage receives the output from stage 1 plus its scaled state, implementing the proper pole-zero relationships for the ladder topology.</p>
<p>Calculate mode offset for filter mode selection logic. This parameter is used in subsequent calculations to determine the appropriate output combination for the selected filter mode.</p>
<p>STAGE 3: Third lowpass pole with enhanced saturation modeling. This stage includes additional nonlinear processing to model the increased distortion that occurs in later stages of the analog ladder.</p>
<p>Apply cubic saturation curve for softer, more musical clipping. The cubic function s(x) = x(1 - x²/3) provides gentle saturation that introduces predominantly odd harmonics, contributing to the warm character associated with analog filters.</p>
<p>STAGE 4: Fourth and final lowpass pole. This stage provides the final 6dB/octave contribution to achieve the complete 24dB/octave response and generates the primary output signal used for feedback and lowpass mode output.</p>
<p>Repeat the filtering process with updated values for enhanced accuracy. This second iteration uses the results from the first pass to refine the nonlinear calculations, providing improved accuracy in modeling the complex interactions between stages in the analog circuit.</p>
<p>Recalculate feedback signal using updated filter state. This improved feedback calculation uses the current filter output rather than the delayed output, providing better accuracy in the nonlinear feedback modeling.</p>
<p>Update saturation state with improved feedback signal. This recalculation of the saturation state provides more accurate nonlinear behavior by incorporating the effects of the first iteration.</p>
<p>Recalculate all filter stages with improved accuracy. This second pass through the filter stages uses the refined saturation and feedback values to provide more accurate modeling of the nonlinear interactions in the analog circuit.</p>
<p>Calculate intermediate signals for filter mode selection. These intermediate calculations provide the signal combinations needed for the various filter modes, particularly the bandpass and highpass responses that require stage differences.</p>
<p>Calculate additional intermediate signal for mode selection. This signal combination is used specifically for certain filter modes that require complex stage interactions and signal summations.</p>
<p>Calculate different filter responses for comprehensive mode selection. This section computes the various frequency response characteristics available from the ladder topology, providing six distinct filter types from the single four-pole structure.</p>
<p>Lowpass 24dB response calculation with temporal averaging. This calculation combines current and delayed outputs with specific weighting coefficients to achieve the desired frequency response and phase characteristics for the 24dB/octave lowpass mode.</p>
<p>Complex filter response calculations for highpass and bandpass modes. These calculations combine multiple filter stages with specific weighting factors to create the desired frequency response shapes for the more complex filter modes.</p>
<p>Select appropriate filter response based on mode parameter. This switch statement provides the six different filter characteristics available from the Huovilainen model, each offering distinct frequency response and musical character.</p>
<p>Traditional Moog lowpass response with steep roll-off. Provides warm, smooth high-frequency attenuation with characteristic resonance peak near cutoff frequency.</p>
<p>Steep highpass response for bright, aggressive filtering. Emphasizes high frequencies while providing steep attenuation below the cutoff frequency.</p>
<p>Narrow bandpass response with steep slopes on both sides. Emphasizes frequencies around the cutoff while attenuating both low and high frequencies with steep characteristics.</p>
<p>Moderate lowpass response using three poles. Provides smoother transition than 24dB mode while maintaining good high-frequency attenuation.</p>
<p>Moderate bandpass response with gentler slopes. Offers wider bandwidth than BP24 mode while maintaining good selectivity around the cutoff frequency.</p>
<p>Gentle highpass response with single-pole characteristic. Provides subtle high-frequency emphasis with gentle low-frequency roll-off suitable for brightening applications.</p>
<p>Graceful handling of invalid mode parameters. Ensures continued operation with musically useful response when invalid mode values are provided.</p>
<p>Update all filter memory elements for subsequent processing. This section commits all calculated values to the filter's internal state variables, ensuring proper temporal continuity and accurate recursive filtering behavior for the next sample period.</p>
<p>Update input history with denormal protection. The noisy input (including thermal noise) becomes the previous input for the next sample's feedback calculations.</p>
<p>Update frequency and resonance parameters. These smoothed parameter values become the current settings for subsequent processing, ensuring artifact-free parameter changes.</p>
<p>Update all filter stage states with denormal protection. These updated state values represent the "memory" of each filter pole and are essential for proper recursive operation.</p>
<p>Update saturation state for nonlinear memory. This state maintains the temporal characteristics of the nonlinear saturation elements for subsequent processing.</p>
<p>Update output delay elements for mode calculations. These delayed signals are required for the complex filter mode calculations and temporal averaging operations.</p>
<p>Return the processed audio sample. The selected output represents the final filtered signal incorporating all nonlinear processing and mode selection.</p>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a30ce9185b837b37d347fa2fbe6e21646" name="a30ce9185b837b37d347fa2fbe6e21646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ce9185b837b37d347fa2fbe6e21646">&#9670;&#160;</a></span>combinedOutput1</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MSPMoogLadderFilter::combinedOutput1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>First combined output signal for multi-mode processing. </p>
<p>Intermediate signal that combines multiple filter stages for complex filter mode calculations. Used in bandpass and highpass mode generation where stage combinations create different frequency response shapes. </p>

</div>
</div>
<a id="a5e7d6fba6f88b9b25f8c48c8bb174153" name="a5e7d6fba6f88b9b25f8c48c8bb174153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7d6fba6f88b9b25f8c48c8bb174153">&#9670;&#160;</a></span>combinedOutput2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MSPMoogLadderFilter::combinedOutput2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Second combined output signal for mode processing. </p>
<p>Additional intermediate signal for filter mode calculations, particularly important for the complex bandpass and highpass responses that require multiple signal combinations and delay elements. </p>

</div>
</div>
<a id="adad646067cba3736c7c82c47892d237b" name="adad646067cba3736c7c82c47892d237b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad646067cba3736c7c82c47892d237b">&#9670;&#160;</a></span>cutoffFrequency</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MSPMoogLadderFilter::cutoffFrequency</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current normalized cutoff frequency. </p>
<p>Internal frequency parameter representing the filter's cutoff frequency in normalized form. This value undergoes frequency warping compensation and is smoothed to prevent audio artifacts during frequency sweeps.</p>
<p>@range [0.0-1.0] normalized relative to sample rate @warping Compensated for bilinear transform frequency compression @smoothing Lowpass filtered to prevent zipper noise </p>

</div>
</div>
<a id="a47bc3baa76db4637be1796930d38c75a" name="a47bc3baa76db4637be1796930d38c75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47bc3baa76db4637be1796930d38c75a">&#9670;&#160;</a></span>finalFilterOutput</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MSPMoogLadderFilter::finalFilterOutput</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Final filter output delay element. </p>
<p>Delayed version of the final filter output, used in feedback calculations and mode processing. This provides the necessary delay for recursive feedback structures and complex mode implementations. </p>

</div>
</div>
<a id="a792a10162938c5c4c6640a50d449c64c" name="a792a10162938c5c4c6640a50d449c64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792a10162938c5c4c6640a50d449c64c">&#9670;&#160;</a></span>frequencyScaleFactor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MSPMoogLadderFilter::frequencyScaleFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frequency scaling factor optimized for current sample rate. </p>
<p>Precomputed scaling factor that optimizes the frequency range and response characteristics for the current sample rate. This factor compensates for sample rate dependencies and ensures consistent filter behavior across different audio system configurations.</p>
<p>@calculation frequencyScaleFactor = sqrt(min(1.0, max(0.0001, 12.5/sampleRate))) @purpose Maintains filter stability and frequency accuracy across sample rates @optimization Computed once during initialization to avoid repeated calculations </p>

</div>
</div>
<a id="adb5a84d9e4fbf97f75a829d38a8d9042" name="adb5a84d9e4fbf97f75a829d38a8d9042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5a84d9e4fbf97f75a829d38a8d9042">&#9670;&#160;</a></span>frequencyWarpFactor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MSPMoogLadderFilter::frequencyWarpFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frequency warping compensation factor for bilinear transform. </p>
<p>Precomputed factor that compensates for frequency warping effects introduced by the bilinear transform used in digital filter implementation. This ensures that the digital filter's frequency response accurately matches the analog prototype across the audible frequency range.</p>
<p>@calculation frequencyWarpFactor = -log(frequencyScaleFactor) @theory_basis Compensation for s-plane to z-plane mapping distortion @frequency_accuracy Ensures cutoff frequency accuracy within 0.1% across range </p>

</div>
</div>
<a id="a71783071551725acfa140ecd62e32c24" name="a71783071551725acfa140ecd62e32c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71783071551725acfa140ecd62e32c24">&#9670;&#160;</a></span>previousInput</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MSPMoogLadderFilter::previousInput</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Previous input sample for delay line implementation. </p>
<p>Stores the input signal from the previous sample period, implementing the z⁻¹ delay element essential for recursive filter structures. Used in feedback calculations and state-space implementation.</p>
<p>@units Normalized audio amplitude [-1.0, +1.0] typical @update_frequency Once per sample in <a class="el" href="#ab331fca52ca6edab349fa55d9145b3e5" title="Process single audio sample through complete Huovilainen ladder algorithm.">processSample()</a> @initialization 0.0 (no previous audio history) </p>

</div>
</div>
<a id="ac92231643e8c95c2e4d23b0bc860b3f2" name="ac92231643e8c95c2e4d23b0bc860b3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92231643e8c95c2e4d23b0bc860b3f2">&#9670;&#160;</a></span>resonanceCoefficient</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MSPMoogLadderFilter::resonanceCoefficient</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current resonance coefficient for feedback calculations. </p>
<p>Internal resonance parameter that controls the amount of positive feedback around the filter ladder. This value is smoothed and frequency-compensated to provide stable resonance behavior across the frequency range.</p>
<p>@range [0.0-1.05] approximately (slightly above 1.0 for self-oscillation) @relationship feedbackStrength = function(resonanceCoefficient, frequency) @smoothing Interpolated over multiple samples to prevent artifacts </p>

</div>
</div>
<a id="a24fa7d208982a7f7a32e56aa61163768" name="a24fa7d208982a7f7a32e56aa61163768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fa7d208982a7f7a32e56aa61163768">&#9670;&#160;</a></span>sampleRate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MSPMoogLadderFilter::sampleRate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Audio system sample rate in Hz. </p>
<p>Fundamental timing reference for all filter calculations including frequency warping, stability analysis, and coefficient computation. This value determines the relationship between normalized frequency parameters and actual audio frequencies.</p>
<p>@units Hertz (samples per second) @range [8000-192000] Hz typical for professional audio applications @precision Double precision for accurate frequency calculations </p>

</div>
</div>
<a id="ad5f2704ec5dc162d262025d528486f18" name="ad5f2704ec5dc162d262025d528486f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f2704ec5dc162d262025d528486f18">&#9670;&#160;</a></span>saturationState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MSPMoogLadderFilter::saturationState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nonlinear saturation state for feedback processing. </p>
<p>Maintains the state of the nonlinear saturation element in the feedback path. This models the soft-clipping behavior of transistors in the original analog circuit and contributes to the warm, musical character of the filter.</p>
<p>@nonlinearity_type Soft saturation with memory (not instantaneous) @musical_effect Adds harmonic richness and prevents harsh clipping @update_rule Includes both current input and previous state for smoothing </p>

</div>
</div>
<a id="ac5ae12a14690568e4f8abd41233431d2" name="ac5ae12a14690568e4f8abd41233431d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ae12a14690568e4f8abd41233431d2">&#9670;&#160;</a></span>stage1State</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MSPMoogLadderFilter::stage1State</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>First filter stage state variable. </p>
<p>Internal state (memory) of the first lowpass pole in the ladder filter. This represents the energy storage element (capacitor) in the analog equivalent circuit and maintains the filter's temporal memory.</p>
<p>@circuit_analog Equivalent to capacitor voltage in first filter stage @update_rule stage1State[n+1] = function(input, stage1State[n], cutoff) @denormal_protection Protected against very small values that degrade CPU performance </p>

</div>
</div>
<a id="a268265c068ac0c3b46f2b8e65c74cd00" name="a268265c068ac0c3b46f2b8e65c74cd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268265c068ac0c3b46f2b8e65c74cd00">&#9670;&#160;</a></span>stage2State</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MSPMoogLadderFilter::stage2State</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Second filter stage state variable. </p>
<p>Internal state of the second lowpass pole, cascaded after the first stage. Contributes to the overall 24dB/octave response and provides intermediate signals for bandpass and other filter mode calculations. </p>

</div>
</div>
<a id="a9598bd5b17b7e65d3da12e8f30575569" name="a9598bd5b17b7e65d3da12e8f30575569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9598bd5b17b7e65d3da12e8f30575569">&#9670;&#160;</a></span>stage3State</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MSPMoogLadderFilter::stage3State</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Third filter stage state variable. </p>
<p>Internal state of the third lowpass pole. This stage includes additional nonlinear processing (cubic saturation) to model the increased distortion that occurs in later stages of the analog ladder filter. </p>

</div>
</div>
<a id="a0f617a374ba5281bb94a2cd97d3f560e" name="a0f617a374ba5281bb94a2cd97d3f560e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f617a374ba5281bb94a2cd97d3f560e">&#9670;&#160;</a></span>stage4DelayedOutput</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MSPMoogLadderFilter::stage4DelayedOutput</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delayed output from fourth stage for mode calculations. </p>
<p>One-sample delayed version of the fourth stage output, required for certain filter mode calculations that need both current and previous values to implement proper frequency response characteristics. </p>

</div>
</div>
<a id="ad54c25fb0f5237829c8032ab057765d3" name="ad54c25fb0f5237829c8032ab057765d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54c25fb0f5237829c8032ab057765d3">&#9670;&#160;</a></span>stage4State</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double MSPMoogLadderFilter::stage4State</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fourth filter stage state variable. </p>
<p>Internal state of the final lowpass pole in the ladder. The output of this stage provides the classic 24dB/octave lowpass response and serves as the primary feedback signal for resonance implementation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>DEV/<a class="el" href="_m_s_p_moog_ladder_filter_8h_source.html">MSPMoogLadderFilter.h</a></li>
<li>DEV/<a class="el" href="_m_s_p_moog_ladder_filter_8cpp.html">MSPMoogLadderFilter.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="class_m_s_p_moog_ladder_filter.html">MSPMoogLadderFilter</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
