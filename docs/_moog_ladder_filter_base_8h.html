<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TR123e - EMCT Computing Final Project: DEV/MoogLadderFilterBase.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TR123e - EMCT Computing Final Project<span id="projectnumber">&#160;Version 1.0</span>
   </div>
   <div id="projectbrief">Research Project Translation from gen~ to embedded Moog synth</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('_moog_ladder_filter_base_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">MoogLadderFilterBase.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Unified foundation architecture for scalar and SIMD Moog ladder filter implementations.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;arm_neon.h&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
</div>
<p><a href="_moog_ladder_filter_base_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:MoogLadderFilterScalar" id="r_MoogLadderFilterScalar"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_moog_ladder_filter_scalar.html">MoogLadderFilterScalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-fidelity scalar implementation of Huovilainen Moog ladder filter.  <a href="class_moog_ladder_filter_scalar.html#details">More...</a><br /></td></tr>
<tr class="memitem:MoogLadderFilterSIMD" id="r_MoogLadderFilterSIMD"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_moog_ladder_filter_s_i_m_d.html">MoogLadderFilterSIMD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-performance SIMD implementation using ARM NEON vectorization.  <a href="class_moog_ladder_filter_s_i_m_d.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a944796a4f8fc8ab508da057b13f5f65e" id="r_a944796a4f8fc8ab508da057b13f5f65e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a944796a4f8fc8ab508da057b13f5f65e">clamp</a> (float x, float a, float b)</td></tr>
<tr class="memdesc:a944796a4f8fc8ab508da057b13f5f65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-performance parameter clamping for audio applications.  <br /></td></tr>
<tr class="memitem:aeadd525126e96d3d42fee0a8ed5061ad" id="r_aeadd525126e96d3d42fee0a8ed5061ad"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeadd525126e96d3d42fee0a8ed5061ad">fixdenorm</a> (float val)</td></tr>
<tr class="memdesc:aeadd525126e96d3d42fee0a8ed5061ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denormal number protection for sustained audio processing performance.  <br /></td></tr>
<tr class="memitem:a961ae60cdf1bc36da5fc79fbc449a2c2" id="r_a961ae60cdf1bc36da5fc79fbc449a2c2"><td class="memItemLeft" align="right" valign="top">float32x4_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a961ae60cdf1bc36da5fc79fbc449a2c2">clamp_f32x4</a> (float32x4_t x, float min_val, float max_val)</td></tr>
<tr class="memdesc:a961ae60cdf1bc36da5fc79fbc449a2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized parameter clamping for SIMD audio processing.  <br /></td></tr>
<tr class="memitem:a003cfe72244b00c937419c21df63aa34" id="r_a003cfe72244b00c937419c21df63aa34"><td class="memItemLeft" align="right" valign="top">float32x4_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a003cfe72244b00c937419c21df63aa34">vdivq_f32</a> (float32x4_t a, float32x4_t b)</td></tr>
<tr class="memdesc:a003cfe72244b00c937419c21df63aa34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficient vector division using Newton-Raphson approximation.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Unified foundation architecture for scalar and SIMD Moog ladder filter implementations. </p>
<p>This header file establishes the architectural foundation for a comprehensive family of Moog ladder filter implementations, providing shared utility functions, common interface definitions, and unified design patterns that ensure consistency across scalar and vectorized implementations while maintaining optimal performance characteristics.</p>
<p>@architectural_philosophy The base architecture employs several key design principles:</p>
<p><b>Unified Interface Design</b>: Common method signatures and parameter conventions across all implementation variants, enabling interchangeable usage and systematic performance comparison without requiring application code modifications.</p>
<p><b>Performance-Oriented Utilities</b>: Shared utility functions optimized for both scalar and vector operations, including specialized denormal protection, parameter clamping, and SIMD-specific mathematical operations.</p>
<p><b>Implementation Flexibility</b>: Support for both ARM NEON vectorized processing and traditional scalar operations within a cohesive framework that maximizes code reuse while enabling implementation-specific optimizations.</p>
<p><b>Research Validation Framework</b>: Consistent interfaces that facilitate systematic algorithm comparison, performance analysis, and validation across different optimization approaches and computational paradigms.</p>
<p>@design_pattern_analysis The architecture implements several established software design patterns:</p>
<p><b>Template Method Pattern</b>: Common interface structure with implementation-specific optimizations, allowing algorithmic variations while maintaining behavioral consistency.</p>
<p><b>Strategy Pattern</b>: Interchangeable scalar and vector implementations that can be selected based on performance requirements and hardware capabilities.</p>
<p><b>Facade Pattern</b>: Simplified interface that abstracts complex internal optimizations and provides clean, intuitive access to advanced filter functionality.</p>
<p><b>Utility Pattern</b>: Shared helper functions that provide common functionality across multiple implementations without code duplication or performance overhead.</p>
<p>@performance_engineering_foundations The base architecture incorporates several performance engineering principles:</p>
<p><b>Computational Efficiency</b>: Inline utility functions eliminate function call overhead while providing compiler optimization opportunities across all implementations.</p>
<p><b>Memory Optimization</b>: Aligned data structures and cache-friendly access patterns optimized for modern processor architectures and memory hierarchies.</p>
<p><b>SIMD Readiness</b>: Native support for ARM NEON vector operations with fallback mechanisms for platforms without vector processing capabilities.</p>
<p><b>Denormal Protection</b>: Comprehensive safeguards against floating-point denormal numbers that can cause severe performance degradation in recursive algorithms.</p>
<p>@license_information GAIALIVE License - MIT-style permissive licensing</p>
<p>Created by Timothy Paul Read on 2025/5/25 Gaia Live DEV: gaialive.com Copyright (c) 2025 Timothy Paul Read</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<dl class="section author"><dt>Author</dt><dd>Timothy Paul Read </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2025/5/25 @organization Gaia Live DEV (gaialive.com) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>Final (updated with corrected setParams and process semantics) </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>2025 Timothy Paul Read </dd></dl>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a944796a4f8fc8ab508da057b13f5f65e" name="a944796a4f8fc8ab508da057b13f5f65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944796a4f8fc8ab508da057b13f5f65e">&#9670;&#160;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float clamp </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>High-performance parameter clamping for audio applications. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input value to be constrained </td></tr>
    <tr><td class="paramname">a</td><td>Minimum allowed value (inclusive) </td></tr>
    <tr><td class="paramname">b</td><td>Maximum allowed value (inclusive) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Clamped value within specified range [a, b]</dd></dl>
<p>Provides efficient parameter range validation essential for preventing numerical instability and maintaining filter stability across all parameter ranges. The implementation uses STL min/max functions that compile to efficient conditional move instructions on modern processors.</p>
<p>@complexity O(1) - Two conditional comparisons @optimization Compiles to efficient conditional move instructions @thread_safety Thread-safe for concurrent read-only access</p>
<p>@mathematical_properties</p><ul>
<li><b>Idempotent</b>: clamp(clamp(x, a, b), a, b) = clamp(x, a, b)</li>
<li><b>Monotonic</b>: If x₁ ≤ x₂, then clamp(x₁, a, b) ≤ clamp(x₂, a, b)</li>
<li><b>Range Preserving</b>: Output always satisfies a ≤ result ≤ b</li>
<li><b>Identity Preserving</b>: If a ≤ x ≤ b, then clamp(x, a, b) = x</li>
</ul>
<p>@usage_examples</p><ul>
<li>Cutoff frequency validation: clamp(frequency, 20.0f, sampleRate/2.0f)</li>
<li>Resonance parameter limiting: clamp(resonance, 0.0f, 1.0f)</li>
<li>Saturation input conditioning: clamp(signal, -1.0f, 1.0f)</li>
</ul>
<p>@performance_considerations The function is marked inline to eliminate call overhead while enabling compiler optimizations. Modern compilers typically generate efficient conditional move instructions that avoid branch misprediction penalties. </p>

</div>
</div>
<a id="a961ae60cdf1bc36da5fc79fbc449a2c2" name="a961ae60cdf1bc36da5fc79fbc449a2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961ae60cdf1bc36da5fc79fbc449a2c2">&#9670;&#160;</a></span>clamp_f32x4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4_t clamp_f32x4 </td>
          <td>(</td>
          <td class="paramtype">float32x4_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>min_val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>max_val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vectorized parameter clamping for SIMD audio processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input vector containing four float values to be clamped </td></tr>
    <tr><td class="paramname">min_val</td><td>Minimum allowed value applied to all vector lanes </td></tr>
    <tr><td class="paramname">max_val</td><td>Maximum allowed value applied to all vector lanes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with all lanes clamped to specified range</dd></dl>
<p>Provides efficient simultaneous range validation for four floating-point values using ARM NEON SIMD instructions. Essential for maintaining parameter stability in vectorized audio processing while leveraging parallel execution capabilities of modern ARM processors.</p>
<p>@complexity O(1) - Two vector comparison operations @simd_efficiency Processes 4 values with cost of single scalar operation @memory_bandwidth Optimized for aligned vector memory access patterns</p>
<p>@arm_neon_implementation Uses optimized ARM NEON instructions for parallel processing:</p><ul>
<li><b>vmaxq_f32</b>: Parallel maximum operation across four lanes</li>
<li><b>vminq_f32</b>: Parallel minimum operation across four lanes</li>
<li><b>vdupq_n_f32</b>: Efficient scalar-to-vector broadcast operation</li>
</ul>
<p>@vectorization_benefits</p><ul>
<li><b>Parallel Processing</b>: Four simultaneous clamp operations</li>
<li><b>Instruction Efficiency</b>: Single instruction operates on multiple data</li>
<li><b>Cache Optimization</b>: Improved spatial locality through vector operations</li>
<li><b>Pipeline Utilization</b>: Better processor pipeline efficiency</li>
<li><b>Power Efficiency</b>: Reduced energy per operation compared to scalar processing</li>
</ul>
<p>@applications</p><ul>
<li>Multi-channel audio parameter validation</li>
<li>Polyphonic synthesizer voice processing</li>
<li>Simultaneous cutoff frequency limiting across filter banks</li>
<li>Batch processing of resonance parameters</li>
<li>Vector-based saturation and limiting operations</li>
</ul>
<p>@performance_characteristics Theoretical performance benefits over scalar clamping:</p><ul>
<li><b>Throughput</b>: 4x improvement for aligned data processing</li>
<li><b>Latency</b>: Minimal additional overhead from vectorization</li>
<li><b>Memory</b>: Improved bandwidth utilization through vector loads</li>
<li><b>Energy</b>: Reduced power consumption per operation on ARM processors </li>
</ul>

</div>
</div>
<a id="aeadd525126e96d3d42fee0a8ed5061ad" name="aeadd525126e96d3d42fee0a8ed5061ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadd525126e96d3d42fee0a8ed5061ad">&#9670;&#160;</a></span>fixdenorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float fixdenorm </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Denormal number protection for sustained audio processing performance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Input floating-point value to be checked and potentially corrected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0.0f if input is denormal, otherwise returns original value unchanged</dd></dl>
<p>Prevents denormal floating-point numbers that can cause severe CPU performance degradation in recursive digital filters. Denormal numbers occur when floating-point values become extremely small and require special processor handling that can be 100x slower than normal arithmetic operations.</p>
<p>@complexity O(1) - Single comparison and conditional assignment @threshold 1×10⁻³⁰ (well below any musically relevant signal levels) @performance_impact Critical for maintaining real-time performance guarantees</p>
<p>@denormal_number_theory IEEE 754 floating-point representation includes denormal (subnormal) numbers that represent values smaller than the minimum normalized value:</p>
<ul>
<li><b>Normal Range</b>: [1.175×10⁻³⁸, 3.403×10³⁸] for 32-bit float</li>
<li><b>Denormal Range</b>: [1.401×10⁻⁴⁵, 1.175×10⁻³⁸] for 32-bit float</li>
<li><b>Processing Cost</b>: 10-100x slower due to software emulation requirements</li>
<li><b>Musical Relevance</b>: Far below noise floor of any practical audio system</li>
</ul>
<p>@performance_analysis In recursive digital filters, denormal numbers can cause:</p><ul>
<li>Severe CPU performance degradation (10-100x slowdown)</li>
<li>Inconsistent real-time performance characteristics</li>
<li>Audio dropouts in resource-constrained systems</li>
<li>Thermal throttling in mobile and embedded devices</li>
<li>Unpredictable latency in real-time audio applications</li>
</ul>
<p>@threshold_selection_rationale The 1×10⁻³⁰ threshold is chosen because:</p><ul>
<li>Well below -600dB (completely inaudible in any practical context)</li>
<li>Above IEEE 754 denormal range (catches all denormal conditions)</li>
<li>Preserves all musically relevant signal content</li>
<li>Provides consistent performance across processor architectures</li>
<li>Eliminates precision-related filter instabilities</li>
</ul>
<p>@usage_patterns Typically applied to filter state variables and feedback signals:</p><ul>
<li>Filter stage outputs before storage in delay lines</li>
<li>Feedback signals in recursive topologies</li>
<li>Envelope generator outputs approaching zero</li>
<li>LFO outputs during fade-in/fade-out periods </li>
</ul>

</div>
</div>
<a id="a003cfe72244b00c937419c21df63aa34" name="a003cfe72244b00c937419c21df63aa34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003cfe72244b00c937419c21df63aa34">&#9670;&#160;</a></span>vdivq_f32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float32x4_t vdivq_f32 </td>
          <td>(</td>
          <td class="paramtype">float32x4_t</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32x4_t</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Efficient vector division using Newton-Raphson approximation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Numerator vector (dividend) </td></tr>
    <tr><td class="paramname">b</td><td>Denominator vector (divisor) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Division result vector (a ÷ b)</dd></dl>
<p>Implements fast vector division essential for SIMD audio processing applications where standard division operations are either unavailable or prohibitively expensive. Uses ARM NEON reciprocal estimate with Newton-Raphson refinement to achieve acceptable accuracy for audio applications while maintaining vectorized performance.</p>
<p>@complexity O(1) - Fixed number of vector operations regardless of input values @accuracy Approximately 16-24 bit precision after refinement @performance Significantly faster than element-wise scalar division</p>
<p>@algorithm_implementation The implementation uses a two-stage process for optimal accuracy:</p>
<p><b>Stage 1: Initial Estimate</b> </p><div class="fragment"><div class="line">reciprocal = vrecpeq_f32(b);  <span class="comment">// Hardware reciprocal estimate (~8-bit accuracy)</span></div>
</div><!-- fragment --><p><b>Stage 2: Newton-Raphson Refinement</b> </p><div class="fragment"><div class="line">reciprocal = vmulq_f32(vrecpsq_f32(b, reciprocal), reciprocal);  <span class="comment">// ~16-bit accuracy</span></div>
</div><!-- fragment --><p><b>Stage 3: Final Multiplication</b> </p><div class="fragment"><div class="line">result = vmulq_f32(a, reciprocal);  <span class="comment">// a × (1/b) = a ÷ b</span></div>
</div><!-- fragment --><p>@mathematical_foundation Newton-Raphson method for reciprocal calculation:</p>
<p>Given f(x) = 1/x - c, finding root gives x = 1/c Iteration formula: x_{n+1} = x_n × (2 - c × x_n)</p>
<p>Where:</p><ul>
<li>c = denominator value</li>
<li>x_0 = initial hardware estimate</li>
<li>Each iteration approximately doubles precision</li>
</ul>
<p>@accuracy_analysis</p><ul>
<li><b>Initial Estimate</b>: ~8-bit precision (hardware vrecpeq_f32)</li>
<li><b>After 1 Iteration</b>: ~16-bit precision (sufficient for most audio)</li>
<li><b>After 2 Iterations</b>: ~24-bit precision (approaching float precision)</li>
<li><b>Error Characteristics</b>: Monotonically decreasing with each iteration</li>
</ul>
<p>@performance_comparison Compared to scalar division in vector context:</p><ul>
<li><b>Scalar Approach</b>: 4 individual division operations</li>
<li><b>Vector Approach</b>: 1 estimate + 1 refinement + 1 multiply</li>
<li><b>Speedup</b>: Typically 2-4x faster depending on processor implementation</li>
<li><b>Energy</b>: Reduced power consumption per operation</li>
</ul>
<p>@usage_contexts Essential for vectorized implementations of:</p><ul>
<li>Rational function approximations (tanh, sigmoid)</li>
<li>Frequency normalization calculations</li>
<li>Gain and scaling factor applications</li>
<li>Complex mathematical expressions requiring division</li>
<li>Filter coefficient calculations with frequency-dependent terms</li>
</ul>
<p>@limitations_and_considerations</p><ul>
<li><b>Accuracy Trade-off</b>: Slightly less precise than true division</li>
<li><b>Denormal Handling</b>: May require additional protection for very small denominators</li>
<li><b>Special Values</b>: Undefined behavior for zero denominators (requires pre-validation)</li>
<li><b>Range Sensitivity</b>: Accuracy may vary across different magnitude ranges </li>
</ul>
<p>Generate initial reciprocal estimate using ARM NEON hardware instruction Provides approximately 8-bit accuracy as starting point for refinement</p>
<p>Apply Newton-Raphson refinement to improve accuracy Formula: x₁ = x₀ × (2 - b × x₀) Implemented as: x₁ = x₀ × vrecpsq_f32(b, x₀) Improves accuracy to approximately 16-bit precision</p>
<p>Compute final division result using refined reciprocal a ÷ b = a × (1 ÷ b)</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_5845c8f75261e7e28026d56abc42daa5.html">DEV</a></li><li class="navelem"><a href="_moog_ladder_filter_base_8h.html">MoogLadderFilterBase.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
